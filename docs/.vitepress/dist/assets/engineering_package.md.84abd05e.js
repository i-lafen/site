import{_ as e,o,c as d,Q as n}from"./chunks/framework.281e52d7.js";const g=JSON.parse('{"title":"包管理与 Monorepo","description":"","frontmatter":{},"headers":[],"relativePath":"engineering/package.md","filePath":"engineering/package.md","lastUpdated":1700799232000}'),a={name:"engineering/package.md"},c=n('<h1 id="包管理与-monorepo" tabindex="-1">包管理与 Monorepo <a class="header-anchor" href="#包管理与-monorepo" aria-label="Permalink to &quot;包管理与 Monorepo&quot;">​</a></h1><h2 id="npm、-yarn、-pnpm-的区别" tabindex="-1">npm、 yarn、 pnpm 的区别 <a class="header-anchor" href="#npm、-yarn、-pnpm-的区别" aria-label="Permalink to &quot;npm、 yarn、 pnpm 的区别&quot;">​</a></h2><h3 id="版本" tabindex="-1">版本 <a class="header-anchor" href="#版本" aria-label="Permalink to &quot;版本&quot;">​</a></h3><p>目前我们常说的 <code>npm</code> 指的是 <code>npm3+</code> 版本。以上三者的区别即 <code>node</code> 包管理方式的区别。</p><h3 id="npm2-的问题" tabindex="-1">npm2 的问题 <a class="header-anchor" href="#npm2-的问题" aria-label="Permalink to &quot;npm2 的问题&quot;">​</a></h3><ul><li><code>npm2</code> 存在的问题是对于 <code>node</code> 包管理是<strong>嵌套</strong>形式，从而导致有些 <code>node</code> 包依赖路径特别深，在 <code>window</code> 中会报错<strong>路径长度超过限制</strong>。且依赖包的子包即使是相同版本也会<strong>被安装多次</strong>，浪费空间时间。</li></ul><h3 id="npm3-和-yarn-特性" tabindex="-1">npm3 和 yarn 特性 <a class="header-anchor" href="#npm3-和-yarn-特性" aria-label="Permalink to &quot;npm3 和 yarn 特性&quot;">​</a></h3><ul><li><code>npm3</code> 和 <code>yarn</code> 都是为了解决 <code>npm2</code> 的嵌套层级问题的，两者实现的方式一致，即将 <code>node</code> 包<strong>扁平化</strong>，统一下载到 <code>node_modules</code> 目录下，可以解决嵌套路径问题和重复下载包问题。</li></ul><h3 id="npm3-和-yarn-新的问题" tabindex="-1">npm3 和 yarn 新的问题 <a class="header-anchor" href="#npm3-和-yarn-新的问题" aria-label="Permalink to &quot;npm3 和 yarn 新的问题&quot;">​</a></h3><p>扁平结构会引发了另外的问题：<strong>幽灵依赖</strong> 以及 <strong>分身</strong>。</p><ul><li>幽灵依赖 <ul><li>由于 <code>node</code> 依赖包之间是扁平的，可以预见的是，我们在项目中安装了一个 <code>node</code> 包，但这个 <code>node</code> 包本身又依赖了其他的 <code>node</code> 包，那么其他的 <code>node</code> 包也会被下载到我们项目的 <code>node_modules</code> 目录下，根据 <code>npm</code> 包的查找规则，业务代码中可以直接使用 <code>node_modules</code> 下的包，但实际上这些包在 <code>package.json</code> 中是不存在的，更无法指定包版本，与我们开发的<strong>直觉不符</strong>。</li><li>幽灵依赖的问题不止于此，例如在项目中的开发依赖 <code>devDependencies</code> 中安装了一个包，这个包依赖的其他包也被提升到 <code>node_modules</code> 下，如果被我们在项目中直接引入使用的话，到生产环境就会报错包找不到，<strong>导致生产事故</strong>。</li></ul></li><li>分身 <ul><li>扁平化会提升包所在的目录层级，但是存在同一个包的<strong>不同版本</strong>，<code>npm</code> 则会选择一个版本提升到 <code>node_modules</code> 下，其他版本<strong>嵌套安装</strong>，这就导致在项目中引用不同包的时候其实是两个<strong>不同的实例</strong>，最终可能导致项目出错。</li></ul></li></ul><h3 id="pnpm-特性" tabindex="-1">pnpm 特性 <a class="header-anchor" href="#pnpm-特性" aria-label="Permalink to &quot;pnpm 特性&quot;">​</a></h3><p>同样是为了解决 <code>npm2</code> 的包嵌套问题，<code>pnpm</code> 采用了另外一种 <code>node</code> 包管理方式，可以避开 <code>npm3</code> 和 <code>yarn</code> 存在的问题。总结来说就是，<code>pnpm</code> 是通过自动<strong>硬链接</strong>和<strong>软链接</strong>来实现包的管理。</p><ul><li>软链接： <ul><li><code>pnpm</code> 安装一个包时，并不会像 <code>npm3</code> 那样将所有的依赖扁平化管理，<code>node_modules</code> 目录下只会有安装的包，其依赖包则会通过 <strong>软链</strong> 的形式链接到 <strong>node_modules/.pnpm</strong> 内部，在 <code>.pnpm</code> 内部去详细管理依赖的版本，从而解决 幽灵依赖 和 分身 的问题。</li><li><code>.pnpm</code> 内部也是扁平化管理的，但是<strong>允许</strong>不同的版本依赖平铺到一个层级。</li></ul></li><li>硬链接： <ul><li><code>.pnpm</code> 目录的一级文件，都是通过直接 硬链接 ，链接到全局的存储空间，从而可以实现多个项目共用一份依赖。</li></ul></li></ul><h2 id="软链和硬链" tabindex="-1">软链和硬链 <a class="header-anchor" href="#软链和硬链" aria-label="Permalink to &quot;软链和硬链&quot;">​</a></h2><p>计算机中我们文件夹中的文件实际上是一个指针，但这个指针并不是直接指向我们在磁盘中存储的文件的位置，而是指向一个 <code>inode</code> 块，<code>inode</code> 中存储着文件在磁盘中的各种信息，一般我们的文件指针指向对应文件的 <code>inode</code>，这类链接称为 <strong>硬链接</strong>。</p><p>但还有一种链接，它存储的并不是实际的值，而是一个硬链接的地址，称为 <strong>软链接</strong>。</p><h2 id="monorepo" tabindex="-1">monorepo <a class="header-anchor" href="#monorepo" aria-label="Permalink to &quot;monorepo&quot;">​</a></h2><p><code>monorepo</code> 即仓库管理模式中的 单仓 模式，与传统的一个项目一个仓库来进行版本管理的方式不同，单仓模式是将多个项目使用一个仓库来进行管理。好处在于，对于有依赖关系的项目可以进行统一的版本管理，统一的代码权限，代码风格一致，一次提交可以修改多个项目。</p><p>那怎样进行依赖包管理</p><h3 id="传统方案-yarn-和-lerna-的问题" tabindex="-1">传统方案 yarn 和 lerna 的问题 <a class="header-anchor" href="#传统方案-yarn-和-lerna-的问题" aria-label="Permalink to &quot;传统方案 yarn 和 lerna 的问题&quot;">​</a></h3><p>常用的 <code>lerna</code> 和 <code>yarn workspace</code> ，这些 <code>monorepo</code> 管理工具主要解决在一个仓库中管理多个 包 遇到的问题：</p><ul><li>第三方依赖重复安装，工作区 <code>package A</code> 和 <code>B</code> 都引用了 <code>C</code>，会在两个包中安装两遍 <code>C</code>，造成时间空间浪费。</li><li>模块之间的引用，如果一个工作区的不同 <code>package</code> 需要互相引用，需要手动 <code>link</code> 操作。</li></ul><h4 id="无论是-yarn-还是-lerna-都可以总结为" tabindex="-1">无论是 yarn 还是 lerna 都可以总结为： <a class="header-anchor" href="#无论是-yarn-还是-lerna-都可以总结为" aria-label="Permalink to &quot;无论是 yarn 还是 lerna 都可以总结为：&quot;">​</a></h4><ul><li>将所有 <code>package</code> 的依赖都以扁平化的方式安装在工作区的根目录 <code>node_modules</code> ，同时对于同一个依赖的不同版本，将其中一个版本安装到根目录，其他版本嵌套安装到 各自 <code>package</code> 下的 <code>node_modules</code>，解决依赖不同版本的冲突问题。</li><li>通过将各个 <code>package</code> 都软链到根目录 <code>node_modules</code>，各个 <code>package</code> 利用 <code>node</code> 的递归查找机制，可以导入其他 <code>package</code>，不需要手动 <code>link</code>。</li><li>通过将各个 <code>package</code> 中的 <code>node_modules</code> 的 <code>bin</code> 文件夹软链到根目录中的 <code>node_modules</code>，保证每个 <code>package</code> 的 <code>npm script</code> 能正常运行。</li></ul><h4 id="虽然解决了核心问题-但是又引入了其他问题" tabindex="-1">虽然解决了核心问题，但是又引入了其他问题： <a class="header-anchor" href="#虽然解决了核心问题-但是又引入了其他问题" aria-label="Permalink to &quot;虽然解决了核心问题，但是又引入了其他问题：&quot;">​</a></h4><ul><li><strong>幽灵依赖</strong>被放大，全部依赖都扁平化到根目录 <code>node_modules</code> ，由于 node 的递归查找，你可以访问到任何其他 <code>package</code> 的依赖，以及依赖的依赖。</li><li><strong>分身</strong>更容易出现，大量依赖的依赖不同版本，随机出现在 <code>node_modules</code> 的第一层或依赖的依赖中。</li></ul><h3 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;pnpm&quot;">​</a></h3><p><code>pnpm</code> 内置了对 <code>monorepo</code> 的支持，只需在工作空间根目录创建 <code>pnpm-workspace.yaml</code> 和 <code>.npmrc</code> 配置文件，同时支持多种配置，还没有传统方案的幽灵依赖和分身的问题。</p>',29),r=[c];function l(p,t,i,s,m,h){return o(),d("div",null,r)}const _=e(a,[["render",l]]);export{g as __pageData,_ as default};
