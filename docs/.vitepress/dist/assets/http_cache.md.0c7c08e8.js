import{_ as e,o,c as t,Q as a}from"./chunks/framework.281e52d7.js";const p=JSON.parse('{"title":"HTTP 缓存","description":"","frontmatter":{},"headers":[],"relativePath":"http/cache.md","filePath":"http/cache.md"}'),i={name:"http/cache.md"},l=a('<h1 id="http-缓存" tabindex="-1">HTTP 缓存 <a class="header-anchor" href="#http-缓存" aria-label="Permalink to &quot;HTTP 缓存&quot;">​</a></h1><ul><li>强缓存（不需要发起请求查询，首先检查强缓存）</li><li>协商缓存（需要发起请求查询）</li><li>缓存位置</li></ul><h2 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h2><ul><li><strong>Expires（http1.0）</strong>：即过期时间，告诉浏览器过期之前都可以从缓存中获取数据，不用重新发起请求，但可能前后端时间不一致导致缓存失败。</li><li><strong>Cache-Control（http1.1）</strong>：过期时长 <ul><li><code>max-age=3600</code></li><li><code>public</code>： 客户端与代理服务器均缓存</li><li><code>private</code>： 仅客户端缓存</li><li><strong><code>no-cache</code>： 跳过当前强缓存，进入协商缓存</strong></li><li><strong><code>no-store</code>： 不缓存</strong></li><li><code>s-maxage</code>：代理服务器的缓存时间</li><li><code>must-revalidate</code>： 缓存一旦过期，则回到源服务器验证</li></ul></li></ul><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h2><ul><li><strong>Last-Modified</strong>： 最后的修改时间，由服务器在响应头中加上此字段给浏览器，如果浏览器再次请求此资源，则会在请求头中携带 <code>If-Modified-Since</code> 字段，此字段为服务器传来的最后的修改时间，服务器拿到该时间后会与服务器中这个时间做对比，判断是否需要 返回新资源 或 <code>304</code></li><li><strong>ETag</strong>： 服务器根据资源内容生成的唯一标志，只要里面内容有改动则会变，服务器通过响应头把这个值返回给浏览器。浏览器再次请求该资源时，会将该值放在请求头中携带 <code>If-None-Match</code> 字段，服务器根据这个值判断是否需要 返回新资源 或 <code>304</code></li><li><strong>两者对比</strong>：<code>Etag</code> 精度高，但性能不佳，两者都支持的情况下，服务器优先考虑 <code>ETag</code></li></ul><h2 id="缓存位置" tabindex="-1">缓存位置 <a class="header-anchor" href="#缓存位置" aria-label="Permalink to &quot;缓存位置&quot;">​</a></h2><ul><li>Service Worker（<strong>离线缓存</strong>就是 <strong>Service Worker Cache</strong>）</li><li>Memory Cache（小的 js、css 文件缓存进内存，大的文件进磁盘）</li><li>Disk Cache（内存使用率较高时，文件优先进入磁盘）</li><li>Push Cache（http2 推送缓存）</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>首先通过 <code>Cache-Control</code> 验证 <strong>强缓存</strong> 是否可用</li><li>强缓存可用，直接使用</li><li>否则进入 <strong>协商缓存</strong> ，即发送 <code>http</code> 请求，服务器通过请求头中的 <code>If-Modified-Since</code> 和 <code>If-None-Match</code> 这些条件请求字段检查资源是否更新</li><li>若资源更新，则返回资源和 <code>200</code> 状态码</li><li>否则，返回 <code>304</code> 状态码，告诉浏览器直接从缓存中获取资源</li></ul>',10),c=[l];function r(d,n,s,h,u,g){return o(),t("div",null,c)}const f=e(i,[["render",r]]);export{p as __pageData,f as default};
