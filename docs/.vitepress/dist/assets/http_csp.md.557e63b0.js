import{_ as o,o as s,c as e,Q as a}from"./chunks/framework.25bfaa42.js";const u=JSON.parse('{"title":"浏览器安全机制","description":"","frontmatter":{},"headers":[],"relativePath":"http/csp.md","filePath":"http/csp.md"}'),l={name:"http/csp.md"},n=a(`<h1 id="浏览器安全机制" tabindex="-1">浏览器安全机制 <a class="header-anchor" href="#浏览器安全机制" aria-label="Permalink to &quot;浏览器安全机制&quot;">​</a></h1><h2 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h2><p>同源策略会隔离不同源的 <code>DOM</code>、页面数据 和 网络通信，进而实现 <code>Web</code> 页面的 安全性。</p><p>同源策略保证了 安全 和 自由 ：</p><ul><li>默认页面中可以引用任意第三方资源，然后又引入 <code>CSP</code> 策略来加以限制；</li><li>默认 <code>XMLHttpRequest</code> 和 <code>fetch</code> 不能跨站请求资源，然后又引入 <code>CORS</code> 策略来支持其跨域；</li><li>不同源的 <code>DOM</code> 是不能相互操纵的，因此浏览器中又实现了 跨文档消息机制，让其比较安全的通信。</li></ul><h2 id="xss" tabindex="-1">xss <a class="header-anchor" href="#xss" aria-label="Permalink to &quot;xss&quot;">​</a></h2><p><code>xss</code> 全称 <code>Cross Site Scripting</code>，即 跨站脚本。<code>xss</code> 攻击是指黑客往 <code>html</code> 文件中 或 <code>dom</code> 中注入 恶意脚本，从而在用户浏览页面时利用该脚本实现攻击。</p><h3 id="恶意脚本能力" tabindex="-1">恶意脚本能力 <a class="header-anchor" href="#恶意脚本能力" aria-label="Permalink to &quot;恶意脚本能力&quot;">​</a></h3><ul><li><strong>窃取 cookie</strong>。通过 <code>document.cookie</code> 获取 <code>cookie</code> 信息，然后通过 <code>XMLHttpRequest</code> 或 <code>fetch</code> 加上 <code>CORS</code> 功能将数据发送给 黑客服务器。</li><li><strong>监听用户行为</strong>。通过注册 <code>addEventListener</code> 接口监听键盘事件，比如获取信用卡等信息。</li><li><strong>修改 DOM 伪造登录窗口</strong>。用来欺骗用户输入账号密码等信息。</li><li><strong>生成浮窗广告</strong>。影响使用。</li></ul><h3 id="攻击方式" tabindex="-1">攻击方式 <a class="header-anchor" href="#攻击方式" aria-label="Permalink to &quot;攻击方式&quot;">​</a></h3><h4 id="存储型-xss" tabindex="-1"><strong>存储型 xss</strong> <a class="header-anchor" href="#存储型-xss" aria-label="Permalink to &quot;**存储型 xss**&quot;">​</a></h4><p><strong>场景</strong>：</p><p>黑客通过网页上的评论功能输入一段 <code>script</code> 标签包裹的恶意 <code>js</code>，如果前后端都没有做好过滤处理的话，这段恶意 <code>js</code> 储存到了数据库中，在其他人打开这个页面加载到这条评论时，浏览器并不知道这是条恶意代码，解析到 <code>script</code> 标签后直接执行了。这就是存储性 <code>xss</code> 攻击。</p><p><strong>特点</strong>：恶意 <code>js</code> 代码会经过数据库储存。</p><h4 id="反射型-xss" tabindex="-1"><strong>反射型 xss</strong> <a class="header-anchor" href="#反射型-xss" aria-label="Permalink to &quot;**反射型 xss**&quot;">​</a></h4><p><strong>场景</strong>：</p><p>恶意脚本作为网络请求的一部分，比如有一个网址后面带有参数 <code>?id=123</code>，然后服务器直接返回给浏览器显示到 <code>html</code> 上。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">http</span><span style="color:#E1E4E8;">:</span><span style="color:#6A737D;">//baidu.com?id=123</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">http</span><span style="color:#24292E;">:</span><span style="color:#6A737D;">//baidu.com?id=123</span></span></code></pre></div><p>这个 <code>url</code> 参数经过 服务器 后，直接返回给 浏览器 页面上解析显示，没有做任何处理；</p><p>此时如果将参数值 换成 一段恶意的 <code>js</code> 代码后，打开网页后就会直接解析执行这段恶意代码从而拿到用户的敏感信息。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">http</span><span style="color:#E1E4E8;">:</span><span style="color:#6A737D;">//baidu.com?id=&lt;script&gt;alert(&#39;反射型xss&#39;)&lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">http</span><span style="color:#24292E;">:</span><span style="color:#6A737D;">//baidu.com?id=&lt;script&gt;alert(&#39;反射型xss&#39;)&lt;/script&gt;</span></span></code></pre></div><p><strong>特点</strong>：服务器并没有储存这段恶意代码，用户被诱导点击链接后即遭受攻击。</p><h4 id="基于-dom-的-xss" tabindex="-1"><strong>基于 DOM 的 xss</strong> <a class="header-anchor" href="#基于-dom-的-xss" aria-label="Permalink to &quot;**基于 DOM 的 xss**&quot;">​</a></h4><p><strong>场景</strong>：</p><p>基于 <code>dom</code> 的 <code>xss</code> 攻击，也称基于文档型 <code>xss</code> 攻击，它并不会经过服务器，而是作为中间人的角色，在数据传输过程中劫持到网络数据包，然后修改里面的 <code>html</code> 文档。</p><p><strong>特点</strong>：通常通过 <code>WIFI</code> 路由劫持 和 本地恶意软件劫持 等。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><code>XSS</code> 攻击是指浏览器中 执行恶意脚本，然后拿到用户的信息进行操作。主要分为 存储型、反射型 和 文档型。</p><p>防范措施主要包括 不要信任用户的输入、利用 <code>CSP</code> 和 <code>Cookie</code> 的 <code>HttpOnly</code> 属性。</p><h3 id="防范-xss-攻击" tabindex="-1">防范 xss 攻击 <a class="header-anchor" href="#防范-xss-攻击" aria-label="Permalink to &quot;防范 xss 攻击&quot;">​</a></h3><ul><li>服务器对输入脚本进行 <strong>过滤</strong> 或 <strong>转码</strong>，过滤 、转码 关键符号和 关键词。可参照 <code>xss.js</code></li><li>利用 <code>CSP</code> 内容安全策略，<strong>核心就是 服务器决定浏览器加载哪些资源</strong><ul><li>限制加载其他域下资源文件，这样即使黑客插入了一段 <code>js</code> 文件也无法被加载。</li><li>禁止向第三方域 提交数据，这样用户数据不会外泄。</li><li>禁止执行 内联脚本 和 未授权的脚本。</li><li><code>csp</code> 提供上报机制，可以帮助我们尽快发现 <code>xss</code> 攻击，以便尽快修复。</li></ul></li><li>利用 <code>HttpOnly</code> 属性。很多 <code>xss</code> 攻击都是盗取 <code>cookie</code>，因此可以通过使用 <code>HttpOnly</code> 属性来保护 <code>cookie</code> 安全，即 <code>cookie</code> 只能通过 <code>http</code> 请求过程中携带，不能通过 <code>document.cookie</code> 来获取。</li></ul><h2 id="csrf" tabindex="-1">CSRF <a class="header-anchor" href="#csrf" aria-label="Permalink to &quot;CSRF&quot;">​</a></h2><h3 id="什么是-csrf-攻击" tabindex="-1">什么是 CSRF 攻击？ <a class="header-anchor" href="#什么是-csrf-攻击" aria-label="Permalink to &quot;什么是 CSRF 攻击？&quot;">​</a></h3><p><code>CSRF</code> （<code>Cross-site request forgery</code>），即跨站请求仿造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。</p><p><code>CSRF</code> 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p><p>举例，在某个论坛点击了黑客精心挑选的小姐姐图片，你点击后，进入了一个新的页面，那可能就是被黑客攻击了。</p><p>怎么被攻击了呢？这点击发生了什么？可能会发生三件事，列举如：</p><ul><li><p>自动发起 <code>GET</code> 请求</p><p>黑客网页中可能有一段这样的代码</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">img</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#FDAEB7;font-style:italic;">img</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">img</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">src</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#B31D28;font-style:italic;">img</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>利用 <code>img</code> 标签，进入网页后自动发送 GET 请求，值得注意的是，这个请求会自动带上关于 <code>xxx.com</code> 的 <code>cookie</code> 信息（这里假定你已经在 <code>xxx.com</code> 中登陆过）。</p><p>假如服务端没有相应的验证机制，他可能认为发请求的是一个正常的用户，因为携带了相应的 <code>cookie</code> ，然后进行相应的各种操作，可以是转账汇款以及其他恶意操作。</p></li><li><p>自动发起 <code>POST</code> 请求。</p><p>黑客可能自己填了一个表单，写了一段自动提交的脚本。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">form</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&#39;hacker-form&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">action</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;https://xxx.com/info&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">method</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;POST&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">input</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">type</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;hidden&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">name</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;user&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;hhh&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">input</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">type</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;hidden&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">name</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;count&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;100&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">form</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;hacker-form&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">();&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">form</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&#39;hacker-form&#39;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">action</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;https://xxx.com/info&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">method</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;POST&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">input</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">type</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;hidden&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">name</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;user&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;hhh&quot;</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">input</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">type</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;hidden&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">name</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;count&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;100&quot;</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">form</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;hacker-form&#39;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">submit</span><span style="color:#24292E;">();&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>同样会携带相应的用户 <code>cookie</code> 信息，让服务器误认为是一个正常的用户在操作，让各种恶意的操作变为可能。</p></li><li><p>引诱用户点击链接发起 <code>GET</code> 请求。</p><p>在黑客网站上，可能会放上一个链接，驱使你点击：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">a</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">href</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;https://xxx/info?user=hhh&amp;count=100&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">taget</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;_blank&quot;</span><span style="color:#E1E4E8;">&gt;点击进入修仙世界&lt;/</span><span style="color:#85E89D;">a</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">a</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">href</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;https://xxx/info?user=hhh&amp;count=100&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">taget</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;_blank&quot;</span><span style="color:#24292E;">&gt;点击进入修仙世界&lt;/</span><span style="color:#22863A;">a</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>点击后，自动发送 <code>get</code> 请求，接下来和自动发 <code>get</code> 请求部分同理。</p></li></ul><p>这就是 <code>CSRF</code> 攻击的原理。和 <code>XSS</code> 攻击对比，<code>CSRF</code> 攻击并不需要将恶意代码注入用户当前页面的 <code>html</code> 文档中，而是跳转到新的页面，利用 <strong>服务器的验证漏洞</strong> 和用户之前的 <strong>登录状态</strong> 来模拟用户进行操作。</p><h3 id="csrf-攻击特点" tabindex="-1">CSRF 攻击特点 <a class="header-anchor" href="#csrf-攻击特点" aria-label="Permalink to &quot;CSRF 攻击特点&quot;">​</a></h3><ul><li>目标站点一定要有 <code>CSRF</code> 漏洞</li><li>用户登录过目标站点，并且保持 <strong>登录状态</strong></li><li>用户需要打开一个第三方站点，可以是 黑客的站点，也可以是一些论坛</li></ul><h3 id="防范-csrf" tabindex="-1">防范 CSRF <a class="header-anchor" href="#防范-csrf" aria-label="Permalink to &quot;防范 CSRF&quot;">​</a></h3><p><code>CSRF</code> 攻击的形成主要是由于 服务器有漏洞导致，对此主要对 服务器 做防护处理：</p><ul><li><strong>充分利用 cookie 的 SameSite 属性</strong>，选项通常设置有 <code>Strict</code>、<code>Lax</code> 和 <code>None</code>： <ul><li><code>Strict</code> 最为严格。如果 <code>SameSite</code> 的值是 <code>Strict</code>，那么浏览器会完全禁止第三方 <code>Cookie</code>。简言之，如果你从极客时间的页面中访问 <code>InfoQ</code> 的资源，而 <code>InfoQ</code> 的某些 <code>Cookie</code> 设置了 <code>SameSite = Strict</code> 的话，那么这些 <code>Cookie</code> 是不会被发送到 <code>InfoQ</code> 的服务器上的。只有你从 <code>InfoQ</code> 的站点去请求 <code>InfoQ</code> 的资源时，才会带上这些 <code>Cookie</code>。</li><li><code>Lax</code> 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 <code>Get</code> 方式的表单这两种方式都会携带 <code>Cookie</code>。但如果在第三方站点中使用 <code>Post</code> 方法，或者通过 <code>img</code>、<code>iframe</code> 等标签加载的 <code>URL</code>，这些场景都不会携带 <code>Cookie</code>。</li><li>而如果使用 <code>None</code> 的话，在任何情况下都会发送 <code>Cookie</code> 数据。</li></ul></li><li><strong>验证请求的来源站点</strong>，通过 <code>http</code> 请求头中的 <strong>Referer</strong> 和 <strong>Origin</strong> 属性，服务器端验证请求来源站点 <ul><li><code>Referer</code> 是 请求来源的 <code>URL</code>（包含具体 <code>URL</code> 路径）</li><li><code>Origin</code> 是请求来源的 域名（不包含具体 <code>URL</code> 路径）</li><li>两者区别在于 <code>Origin</code> 只包含 域名，服务器会优先判断 <code>Origin</code>，请求头中没有的话再看情况判断 <code>Referer</code></li><li>但是这两者都是可以伪造的，通过 <code>Ajax</code> 中自定义请求头即可，<strong>安全性略差</strong></li></ul></li><li><strong>CSRF Token</strong>，服务器给浏览器生成一段 字符串 ，植入到返回的 页面中，在浏览器发起转账请求时带上 <code>CSRF Token</code>，服务器验证是否合法，如果请求是从第三方站点发出，则无法获取 <code>CSRF Token</code>。</li></ul><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><code>CSRF</code>（Cross-site request forgery）即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客网站，然后黑客利用用户目前的登录状态发起跨站请求。</p><p><code>CSRF</code> 攻击一般会有三种方式：</p><ul><li>自动 <code>GET</code> 请求</li><li>自动 <code>POST</code> 请求</li><li>诱导点击发送 <code>GET</code> 请求</li></ul><p><strong>防范措施</strong>：利用 <code>cookie</code> 的 <code>SameSite</code> 属性、验证来源站点的 <code>Referer</code> 、 <code>Origin</code> 和 <code>CSRF Token</code>。</p>`,49),c=[n];function t(p,r,d,i,E,y){return s(),e("div",null,c)}const g=o(l,[["render",t]]);export{u as __pageData,g as default};
