import{_ as e,o,c as a,Q as t}from"./chunks/framework.d544cf0e.js";const f=JSON.parse('{"title":"Inline-block 元素空白问题","description":"","frontmatter":{},"headers":[],"relativePath":"css/inline-block.md","filePath":"css/inline-block.md","lastUpdated":1692961506000}'),c={name:"css/inline-block.md"},l=t('<h1 id="inline-block-元素空白问题" tabindex="-1">Inline-block 元素空白问题 <a class="header-anchor" href="#inline-block-元素空白问题" aria-label="Permalink to &quot;Inline-block 元素空白问题&quot;">​</a></h1><h2 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h2><p>两个 <code>display: inline-block</code> 的元素并排会产生一段 空白</p><h2 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h2><p><strong>行内块</strong> 元素中间的 空白符（空格、回车）会被浏览器处理，根据 <code>css</code> 中 的 <code>white-space</code> 属性的处理方式（<code>normal</code> 合并多余空白），原来 <code>html</code> 代码中的回车会被转成一个 <strong>空白符</strong>，在字体不为 <code>0</code> 的情况下，空白符占据一定的 <strong>宽度</strong>，所以导致出现了 <strong>间隙</strong>。</p><h2 id="解决" tabindex="-1">解决 <a class="header-anchor" href="#解决" aria-label="Permalink to &quot;解决&quot;">​</a></h2><ul><li>将子元素写在同一行</li><li>设置父元素 <code>font-size: 0</code>，子元素设置 正确的 <code>font-size</code></li><li>改为 <code>flex</code> 布局</li><li>改为 <code>float</code> 布局</li></ul>',7),n=[l];function i(s,d,r,h,_,p){return o(),a("div",null,n)}const k=e(c,[["render",i]]);export{f as __pageData,k as default};
