import{_ as o,o as e,c as l,Q as t}from"./chunks/framework.d544cf0e.js";const h=JSON.parse('{"title":"从输入 URL 到页面展示过程","description":"","frontmatter":{},"headers":[],"relativePath":"http/url-to-page.md","filePath":"http/url-to-page.md","lastUpdated":1692961506000}'),c={name:"http/url-to-page.md"},d=t('<h1 id="从输入-url-到页面展示过程" tabindex="-1">从输入 URL 到页面展示过程 <a class="header-anchor" href="#从输入-url-到页面展示过程" aria-label="Permalink to &quot;从输入 URL 到页面展示过程&quot;">​</a></h1><ul><li>用户输入 <code>url</code> 回车</li><li>浏览器进程检查 <code>url</code> ，<strong>组装协议</strong>，构成完整的 <code>url</code></li><li>浏览器进程通过 进程间通信（<code>IPC</code>）把 <code>url</code> 请求发送给<strong>网络进程</strong></li><li>网络进程接收到 <code>url</code> 请求后检查本地缓存是否 <strong>缓存</strong> 了该请求资源，如果有则将该资源返回给浏览器进程（涉及<strong>强缓存</strong>判断）</li><li><strong>如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下</strong>： <ul><li>进行 <code>DNS</code> 解析，获取服务器 <code>ip地址</code> ，<code>端口</code></li><li>利用 <code>ip</code> 地址和服务器建立 <code>tcp</code> 连接</li><li>构建请求头信息</li><li>发送请求</li><li>服务器响应后，网络进程接收响应头和响应信息，并<strong>解析响应</strong>内容</li></ul></li><li><strong>网络进程解析响应流程</strong>： <ul><li>检查状态码，<code>301/302</code> 则需重定向，从 <code>Location</code> 中读取地址，重新进行第 <code>4</code> 步，如果是 <code>200</code>，则继续处理请求。</li><li><code>304</code> 状态码：命中<strong>协商缓存</strong>，直接从本地缓存中读取内容。</li><li><code>200</code> 状态码：检查响应类型 <code>Content-Type</code>，如果是字节流类型，则将该请求提交给下载管理器，该请求流程结束，不再进行后续渲染，如果是 <code>html</code> 则通知浏览器进程准备渲染进程准备进行渲染。</li></ul></li><li><strong>准备渲染进程</strong><ul><li>浏览器进程检查当前 <code>url</code> 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li></ul></li><li><strong>传输数据、更新状态</strong><ul><li>渲染进程准备好后，浏览器向渲染进程发起 <strong>提交文档</strong> 的消息，渲染进程接收到消息和网络进程建立传输数据的 <strong>管道</strong> 。</li><li>渲染进程接收到数据后，向浏览器发送 <strong>确认提交</strong> 。</li><li>浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 <code>url</code> 、前进后退的历史状态、更新 <code>web</code> 页面。</li></ul></li><li><strong>更新 web 页面包含三个阶段：DOM生成、样式计算和布局</strong><ul><li>浏览器不能直接理解 <code>html</code> 数据，所以第一步需要将其转换为浏览器能够理解的 <code>DOM</code> 树结构；</li><li>生成 <code>DOM</code> 树后，还需要根据 <code>css</code> 样式表，来计算出 <code>DOM</code> 树所有节点的样式，更新 <code>render</code> 树；</li><li>最后计算 <code>DOM</code> 元素的布局信息，使其都保存在布局树中。</li></ul></li></ul>',2),i=[d];function r(s,n,a,g,u,_){return e(),l("div",null,i)}const m=o(c,[["render",r]]);export{h as __pageData,m as default};
