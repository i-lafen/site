import{_ as a,o as e,c as t,Q as o}from"./chunks/framework.281e52d7.js";const m=JSON.parse('{"title":"简述三次握手四次挥手","description":"","frontmatter":{},"headers":[],"relativePath":"http/hand.md","filePath":"http/hand.md"}'),l={name:"http/hand.md"},i=o('<h1 id="简述三次握手四次挥手" tabindex="-1">简述三次握手四次挥手 <a class="header-anchor" href="#简述三次握手四次挥手" aria-label="Permalink to &quot;简述三次握手四次挥手&quot;">​</a></h1><h2 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h2><ol><li>客户端向服务端发起连接询问</li><li>服务端回应客户端可连接</li><li>客户端回应服务端收到可连接的回应，至此建立连接</li></ol><h3 id="为什么不是两次" tabindex="-1">为什么不是两次？ <a class="header-anchor" href="#为什么不是两次" aria-label="Permalink to &quot;为什么不是两次？&quot;">​</a></h3><blockquote><p>根本原因是无法确认客户端的 接收能力。</p></blockquote><p>如果是两次，客户端第一次发起连接询问，由于网络原因滞留在了网络中，迟迟没有到达服务端，此时 <code>tcp</code> 以为丢包了，于是重发，两次握手建立了连接，传输数据后关闭连接。</p><p>但是此时滞留网络中的第一次询问到达了服务端，由于是两次握手，此时服务端没有确认客户端的接受能力，就默认建立了连接，但是客户端此时早已断开了连接，从而导致服务端连接资源的浪费，所以至少需要 三次握手</p><h2 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h2><ol><li>客户端向服务端发起断开连接请求</li><li>服务端回应客户端，已收到断开请求，但并未确认可以断开连接，此时服务端可能仍有数据向客户端发送</li><li>服务端数据发完，服务端向客户端发送确认可以断开连接</li><li>客户端回应服务端确认断开连接</li></ol><h3 id="为什么不是三次" tabindex="-1">为什么不是三次？ <a class="header-anchor" href="#为什么不是三次" aria-label="Permalink to &quot;为什么不是三次？&quot;">​</a></h3><p>如果将第 <code>2</code> 和第 <code>3</code> 步合并，此时长时间的延迟会导致客户端误以为服务端没有收到第 <code>1</code> 步的断开请求，从而导致客户端不断重发第 <code>1</code> 步。</p>',11),r=[i];function c(d,h,n,s,_,p){return e(),t("div",null,r)}const f=a(l,[["render",c]]);export{m as __pageData,f as default};
