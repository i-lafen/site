import{_ as e,o,c as d,Q as c}from"./chunks/framework.d544cf0e.js";const a="/site/assets/dns.b5ace7de.png",k=JSON.parse('{"title":"Interview","description":"","frontmatter":{},"headers":[],"relativePath":"web/interview.md","filePath":"web/interview.md","lastUpdated":1692961506000}'),l={name:"web/interview.md"},i=c('<h1 id="interview" tabindex="-1">Interview <a class="header-anchor" href="#interview" aria-label="Permalink to &quot;Interview&quot;">​</a></h1><h2 id="作用域" tabindex="-1">作用域 <a class="header-anchor" href="#作用域" aria-label="Permalink to &quot;作用域&quot;">​</a></h2><p>变量的可访问范围，即 作用域 控制着变量的 可见性 和 生命周期，代码位置 （ 静态 的 词法作用域 ） 决定了变量的 可见性 与 生命周期</p><h2 id="移动端-1px-问题" tabindex="-1">移动端 1px 问题 <a class="header-anchor" href="#移动端-1px-问题" aria-label="Permalink to &quot;移动端 1px 问题&quot;">​</a></h2><ul><li>伪元素 + <code>border: 1px</code> + <code>transform: scale(0.5)</code> （<strong>优解</strong>）</li><li>直接 <code>0.5px</code> ，安卓不支持</li><li><code>border-image</code> ，设置渐变，半边透明</li><li><code>border-shadow</code> ， 模拟边框，但有阴影、模糊， <code>safari</code> 不支持 <code>0.5px</code> 的 <code>box-shadow</code></li></ul><h2 id="常见的性能优化相关问题" tabindex="-1">常见的性能优化相关问题 <a class="header-anchor" href="#常见的性能优化相关问题" aria-label="Permalink to &quot;常见的性能优化相关问题&quot;">​</a></h2><p>性能优化大致可以按以下方向进行</p><h3 id="代码、性能问题" tabindex="-1">代码、性能问题 <a class="header-anchor" href="#代码、性能问题" aria-label="Permalink to &quot;代码、性能问题&quot;">​</a></h3><ul><li>数据埋点上报</li><li>控制台 <code>network</code> 、 <code>performance</code> 工具分析</li><li><code>webpack-bundle-analyzer</code> 插件打包产物分析</li></ul><h3 id="http-相关" tabindex="-1">http 相关 <a class="header-anchor" href="#http-相关" aria-label="Permalink to &quot;http 相关&quot;">​</a></h3><ul><li>强缓存、协商缓存</li><li><code>gzip</code> 压缩</li></ul><h3 id="图片相关" tabindex="-1">图片相关 <a class="header-anchor" href="#图片相关" aria-label="Permalink to &quot;图片相关&quot;">​</a></h3><ul><li>图片压缩，小图 <code>base64</code> （一般 <code>&lt; 10kb</code> 转 <code>base64</code>）</li><li>图片懒加载、预加载</li><li>字体图标、 <code>svg</code></li></ul><h3 id="webpack-相关" tabindex="-1">webpack 相关 <a class="header-anchor" href="#webpack-相关" aria-label="Permalink to &quot;webpack 相关&quot;">​</a></h3><ul><li>多进程打包</li><li>缓存 <code>ast</code></li><li>使用 <code>cdn</code></li></ul><h3 id="代码优化" tabindex="-1">代码优化 <a class="header-anchor" href="#代码优化" aria-label="Permalink to &quot;代码优化&quot;">​</a></h3><ul><li>耗时计算使用 <code>web worker</code></li></ul><h3 id="单页应用首屏加载速度慢可能原因" tabindex="-1">单页应用首屏加载速度慢可能原因 <a class="header-anchor" href="#单页应用首屏加载速度慢可能原因" aria-label="Permalink to &quot;单页应用首屏加载速度慢可能原因&quot;">​</a></h3><h4 id="可能原因" tabindex="-1">可能原因 <a class="header-anchor" href="#可能原因" aria-label="Permalink to &quot;可能原因&quot;">​</a></h4><ul><li>网络延迟</li><li>资源文件体积大小</li><li>脚本执行时间过长</li></ul><h4 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-label="Permalink to &quot;解决方法&quot;">​</a></h4><ul><li>减小入口文件体积 <ul><li>路由懒加载，已函数形式加载路由</li><li><code>Tree-shaking</code> 去除未使用的代码</li></ul></li><li>静态资源本地缓存 <ul><li>采用 <code>http</code> 缓存，后端返回资源设置 <code>Expire</code> 、 <code>Cache-control</code>、<code>Last-Modified</code>、<code>Etag</code> 等</li><li>前端合理利用 <code>localStorage</code></li></ul></li><li><code>ui</code> 框架按需加载、 框架资源使用 <code>CDN</code></li><li>图片压缩、懒加载</li><li>开启 <code>GZip</code> 压缩</li></ul><h2 id="前端埋点方案" tabindex="-1">前端埋点方案 <a class="header-anchor" href="#前端埋点方案" aria-label="Permalink to &quot;前端埋点方案&quot;">​</a></h2><ul><li><code>new Image()</code> 方式上传，无跨域问题，不挂载页面不影响页面，采用 <code>1</code> 像素的 <code>gif</code> 图体积较小</li><li><code>navigator.sendBeacon(url, data)</code> 方法上传一些统计和诊断数据，不受页面卸载影响，不影响下一个页面的载入，可优先使用此方法来做埋点上传， <code>new Image()</code> 做兜底</li></ul><h2 id="组件和插件区别" tabindex="-1">组件和插件区别 <a class="header-anchor" href="#组件和插件区别" aria-label="Permalink to &quot;组件和插件区别&quot;">​</a></h2><ul><li>编写形式 <ul><li>组件编写：<code>.vue</code> 文件或 <code>.jsx</code>、<code>.tsx</code> 文件</li><li>插件编写：包含 <code>install</code> 方法的<strong>对象</strong></li></ul></li><li>注册方式 <ul><li>组件 <code>Vue.component()</code></li><li>插件 <code>Vue.use()</code></li></ul></li><li>使用场景 <ul><li>组件用来构成 <code>App</code> 业务模块</li><li>插件用来增强 <code>Vue</code> 功能</li></ul></li></ul><h2 id="虚拟-dom" tabindex="-1">虚拟 dom <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 dom&quot;">​</a></h2><p>描述 <code>dom</code> 结构的 <code>js</code> 对象，相比于真实 <code>dom</code> ，更加轻便，对于需要频繁更新的 <code>dom</code> 结构，使用 虚拟 <code>dom</code> 更能体现其快速更新能力。</p><h2 id="v-for-时-key-在组件中的作用" tabindex="-1">v-for 时 key 在组件中的作用 <a class="header-anchor" href="#v-for-时-key-在组件中的作用" aria-label="Permalink to &quot;v-for 时 key 在组件中的作用&quot;">​</a></h2><p><code>diff</code> 过程中，唯一的 <code>key</code> 能够有助于 <code>vue</code> 去判断同级的两个新旧节点是否相同节点，以便快速进行匹配判断节点是移动、创建、还是删除，从而减少不必要的重新渲染。</p><h2 id="keep-alive-理解" tabindex="-1">keep-alive 理解 <a class="header-anchor" href="#keep-alive-理解" aria-label="Permalink to &quot;keep-alive 理解&quot;">​</a></h2><p><code>vue</code> 的内置组件，能够保留组件切换时的数据状态，并采用 <code>LRU</code> 缓存策略。</p><p>但是 <code>keep-alive</code> 并没有提供清理缓存组件的办法，只能通过动态更新 <code>include</code> 的方式来失效想要清理缓存的组件。</p><h2 id="websocket-链接" tabindex="-1">websocket 链接 <a class="header-anchor" href="#websocket-链接" aria-label="Permalink to &quot;websocket 链接&quot;">​</a></h2><p><code>websocket</code> 是一种基于 <code>tcp</code> 协议的双向通信协议。</p><ul><li>利用 <code>http</code> 建立连接，首先建立握手过程，与普通 <code>http</code> 请求类似，但包含了一些特殊头部字段，例如 <code>Upgrade: Websocket</code> 和 <code>Connection: Upgrade</code></li><li>建立 <code>tcp</code> 连接</li><li>双向通信</li><li>断开连接，任意一方发送特殊的控制帧（ <code>Close Frame</code> ）</li></ul><h2 id="https-是如何保证安全的" tabindex="-1">https 是如何保证安全的 <a class="header-anchor" href="#https-是如何保证安全的" aria-label="Permalink to &quot;https 是如何保证安全的&quot;">​</a></h2><p><code>https</code> 是一种基于 <code>tls/ssl</code> 协议的安全传输协议，它可以通过加密和认证等措施来保护数据传输过程中的安全性和隐私性。</p><ul><li>加密传输 ： 使用 对称加密 来传输数据， 非对称加密 来传输公钥，保证 公钥 和 数据安全</li><li>身份认证 ： 使用 <code>ca</code> 证书对客户端和服务器进行认证，防止伪装攻击</li><li>完整性校验 ： 使用消息摘要算法对传输的数据进行校验，防止传输过程中被篡改</li><li>防止重放攻击 ： 使用时间戳和随机数等技术对请求和响应标记，防止重放攻击</li></ul><h2 id="小程序的双线程架构" tabindex="-1">小程序的双线程架构 <a class="header-anchor" href="#小程序的双线程架构" aria-label="Permalink to &quot;小程序的双线程架构&quot;">​</a></h2><p>双线程 是指小程序运行时开启两个线程运行的，分别是 <strong>渲染线程</strong> 和 <strong>逻辑线程</strong> 。</p><ul><li>渲染线程 ， 负责渲染界面，包括解析 <code>wxml</code> 、 <code>wxss</code> 、样式计算、布局排版 和 绘制视图 等操作</li><li>逻辑线程 ， 处理业务逻辑、数据，包括调用 小程序 <code>api</code> 、 事件回调、请求网络，与客户端通信 等操作</li></ul><p>通过双线程协同，能够实现小程序的高性能和流畅体验，并且不支持直接操作 <code>dom</code> 。</p><p>逻辑线程通过 <code>setData()</code> 方式通知渲染线程更新，渲染线程通过 <code>bindtap</code> 等事件方式调用逻辑线程。</p><h2 id="promise-then-的第二个参数和-catch-的区别" tabindex="-1">Promise.then 的第二个参数和 catch 的区别 <a class="header-anchor" href="#promise-then-的第二个参数和-catch-的区别" aria-label="Permalink to &quot;Promise.then 的第二个参数和 catch 的区别&quot;">​</a></h2><p>两者都是处理 <code>reject</code> 情况的，推荐使用 <code>catch</code></p><ul><li>使用 <code>then</code> 第二个参数时候，异常情况会在此被处理掉，不会往下链条传递</li><li><code>catch</code> 可以兜住整个 <code>promise</code> 链条上的异常情况，推荐使用</li></ul><h2 id="web-worker" tabindex="-1">web worker <a class="header-anchor" href="#web-worker" aria-label="Permalink to &quot;web worker&quot;">​</a></h2><p><code>web worker</code> 是可以新建一个后台线程去执行耗时 <code>js</code> 任务，避免耗时任务阻塞主线程</p><ul><li>独立线程 ， 避免阻塞主线程风险</li><li>沙箱环境 ， <code>web worker</code> 代码运行在一个受限沙箱中，不能访问 <code>dom</code> ，全局变量等资源，保证数据安全稳定</li><li>事件通信 ， 通过 <code>postMessage</code> 和 <code>message</code> 事件来与主线程通信</li></ul><h2 id="dns-查询" tabindex="-1">DNS 查询 <a class="header-anchor" href="#dns-查询" aria-label="Permalink to &quot;DNS 查询&quot;">​</a></h2><p><code>DNS</code> 查询是 域名的 <code>IP</code> 地址查询过程，其中会依次经过 <strong>递归查询</strong>、<strong>迭代查询</strong>，如客户端发起一个 <code>DNS</code> 查询流程</p><ol><li>本地 浏览器 首先查询是否有该 域名 的缓存，有则返回</li><li>查询 操作系统 中是否缓存该域名</li><li>查询 本地 <code>host</code> 是否缓存该域名</li><li>请求 本地 <code>DNS</code> 服务器，看是否缓存了该域名</li><li>如果还找不到，本地 <code>DNS</code> 服务器则请求 <strong>根域名服务器</strong>。例如 想要查找 <code>www.baidu.com</code> 的 <code>IP</code> 地址，根域名服务器 会返回 <code>.com</code> 这个 顶级域名服务器 的 <code>IP</code> 地址，让 本地 <code>DNS</code> 服务器去这里找</li><li>本地 <code>DNS</code> 服务器向 <strong>顶级域名服务器</strong> 发起查询 <code>www.baidu.com</code> 的 <code>IP</code> 地址 请求，返回该域名地址的 <strong>权威服务器</strong> 地址</li><li>本地 <code>DNS</code> 服务器 向 <strong>权威服务器</strong> 发起查询 <code>www.baidu.com</code> 的 <code>IP</code> 地址 请求，返回该域名的 <code>IP</code> 地址</li><li>本地 <code>DNS</code> 服务器将 查到的 <code>IP</code> 地址返回给客户端</li><li>缓存 该 <code>IP</code> 地址</li></ol><blockquote><p>其中 第 <code>1 - 4</code> 为 递归查询 ， <code>5 - 7</code> 为 迭代查询</p></blockquote><p><img src="'+a+'" alt="dns"></p><p>域名的层级关系类似于一个树状结构</p><ul><li>根 <code>DNS</code> 服务器（ <code>.</code> ）</li><li>顶级域名服务器（ <code>.com</code> ）</li><li>权威 <code>DNS</code> 服务器（ <code>server.com</code> ）</li></ul><h2 id="cdn-基本原理" tabindex="-1">CDN 基本原理 <a class="header-anchor" href="#cdn-基本原理" aria-label="Permalink to &quot;CDN 基本原理&quot;">​</a></h2><p>内容分发网络，在用户访问相对集中的网络设置一些 缓存服务器 存放相对稳定的资源，当用户访问相应的资源时，由最近的 缓存服务器 （ <code>CDN</code> ） 代替 源站点 响应并返回资源。</p>',59),t=[i];function r(h,n,s,u,p,b){return o(),d("div",null,t)}const w=e(l,[["render",r]]);export{k as __pageData,w as default};
